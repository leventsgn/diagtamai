import React, { useCallback, useEffect, useRef } from "react";
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  Handle,
  Position,
  useReactFlow,
  ReactFlowProvider,
  type Node,
  type Edge,
  type NodeProps,
  ConnectionMode,
  getNodesBounds,
  getViewportForBounds,
} from "reactflow";
import "reactflow/dist/style.css";
import "reactflow/dist/base.css";
import dagre from "dagre";
import { toPng } from "html-to-image";
import jsPDF from "jspdf";
import * as Icons from "lucide-react";
import { useAppStore, getNodeDimensions, getAbsolutePosition, calculateEdgeHandles } from "../store/useAppStore";


const resolveLayoutOptions = (nodes: Node[], edges: Edge[], preferredDir?: string, preferredRanker?: string) => {
  const nodeCount = nodes.length;
  const edgeCount = edges.length;
  const avgDegree = nodeCount > 0 ? edgeCount / nodeCount : 0;
  let density: 'compact' | 'comfortable' | 'spacious' = 'compact';
  if (nodeCount >= 25 || avgDegree >= 1.8) density = 'comfortable';
  else if (nodeCount >= 40) density = 'spacious';
  return {
    density,
    ranker: (preferredRanker as any) || 'network-simplex',
    direction: (preferredDir as any) || 'LR'
  };
};

const getLayoutedElements = (nodes: Node[], edges: Edge[], direction: 'TB' | 'LR', density: 'compact' | 'comfortable' | 'spacious', ranker: string) => {
  const dagreGraph = new dagre.graphlib.Graph();
  dagreGraph.setDefaultEdgeLabel(() => ({}));

  const densityMap = {
    compact: { nodesep: 80, ranksep: 120, edgesep: 40, marginx: 40, marginy: 40 },
    comfortable: { nodesep: 120, ranksep: 180, edgesep: 60, marginx: 60, marginy: 60 },
    spacious: { nodesep: 180, ranksep: 240, edgesep: 80, marginx: 100, marginy: 100 },
  } as const;
  const baseSpacing = densityMap[density];
  const scale = Math.min(1.3, 1 + Math.max(0, nodes.length - 20) / 100);

  dagreGraph.setGraph({
    rankdir: direction,
    nodesep: Math.round(baseSpacing.nodesep * scale),
    ranksep: Math.round(baseSpacing.ranksep * scale),
    edgesep: Math.round(baseSpacing.edgesep * scale),
    marginx: Math.round(baseSpacing.marginx * scale),
    marginy: Math.round(baseSpacing.marginy * scale),
    ranker,
  });

  const parentNodes = nodes.filter(n => !(n.data as any).parent);
  const childNodes = nodes.filter(n => (n.data as any).parent);

  parentNodes.forEach((node) => {
    let dims = getNodeDimensions(node);
    const isGroup = (node.data as any)?.nodeType === 'group';
    if (isGroup) {
      const children = nodes.filter(n => (n.data as any).parent === node.id);
      if (children.length > 0) {
        const cols = Math.min(2, Math.ceil(Math.sqrt(children.length)));
        const rows = Math.ceil(children.length / cols);
        dims = { width: (40 * 2) + (cols * 180) + ((cols - 1) * 30), height: (40 * 2) + 30 + (rows * 120) + ((rows - 1) * 30) };
        (node.data as any).width = dims.width;
        (node.data as any).height = dims.height;
        node.style = { ...node.style, width: dims.width, height: dims.height };
      }
    }
    dagreGraph.setNode(node.id, dims);
  });

  edges.forEach((edge) => {
    const s = nodes.find(n => n.id === edge.source);
    const t = nodes.find(n => n.id === edge.target);
    if (s && t) {
      const su = (s.data as any).parent || s.id;
      const tv = (t.data as any).parent || t.id;
      if (su !== tv) dagreGraph.setEdge(su, tv);
    }
  });

  dagre.layout(dagreGraph);

  const layoutedNodes = parentNodes.map((node) => {
    const pos = dagreGraph.node(node.id);
    const dims = getNodeDimensions(node);
    return { ...node, position: { x: pos.x - dims.width / 2, y: pos.y - dims.height / 2 } };
  });

  const childrenByParent = new Map<string, Node[]>();
  childNodes.forEach(c => {
    const p = (c.data as any).parent;
    if (!childrenByParent.has(p)) childrenByParent.set(p, []);
    childrenByParent.get(p)!.push(c);
  });

  childrenByParent.forEach((siblings, parentId) => {
    const p = layoutedNodes.find(n => n.id === parentId);
    if (!p) return;
    const cols = Math.min(2, Math.ceil(Math.sqrt(siblings.length)));
    const gridX = ((p.data as any).width - ((cols * 180) + (cols - 1) * 30)) / 2;
    siblings.forEach((c, i) => {
      layoutedNodes.push({ ...c, position: { x: gridX + (i % cols) * 210, y: 70 + Math.floor(i / cols) * 150 } });
    });
  });

  return { nodes: layoutedNodes, edges };
};

// --- COMPONENTS ---

function CustomNode({ data, selected }: NodeProps) {
  const nodeType = data.nodeType || 'process';
  const nodeStyle = { background: 'var(--card-bg)', color: 'var(--text)', border: selected ? 'var(--accent)' : 'var(--border)', accent: 'var(--accent)' };

  const getSVGIcon = (type: string) => {
    const t = type.toLowerCase();

    // Mapping for common architectural terms to Lucide icon names
    const iconMapping: Record<string, keyof typeof Icons> = {
      // Core
      process: "Activity",
      decision: "GitBranch",
      actor: "UserSquare2",
      group: "Boxes",
      note: "StickyNote",

      // Frontend
      web_client: "Globe",
      mobile_app: "Smartphone",
      user: "User",
      tablet: "Tablet",
      desktop: "Monitor",
      dashboard: "LayoutDashboard",
      form: "ClipboardList",

      // Backend
      api_gateway: "Network",
      load_balancer: "ArrowDownUp",
      microservice: "Box",
      server: "Server",
      lambda: "Zap",
      cloud_service: "Cloud",
      auth_service: "Lock",
      worker: "Cog",
      cron: "Clock",
      logic: "Workflow",

      // Data
      sql_database: "Database",
      nosql: "HardDrive",
      cache: "Zap",
      message_broker: "MessageSquare",
      object_storage: "HardDrive",
      queue: "ListTree",
      storage: "HardDrive",
      search: "Search",
      logging: "FileText",
      analytics: "BarChart3",
      big_data: "DatabaseBackup",
      data_warehouse: "Archive",

      // Infrastructure
      cloud: "Cloud",
      vpc: "ShieldEllipsis",
      subnet: "UnfoldVertical",
      firewall: "ShieldCheck",
      cdn: "Radio",
      dns: "Dna",
      vpn: "ShieldCheck",
      region: "Map",
      zone: "LocateFixed",

      // DevSecOps
      jenkins: "Settings",
      git: "GitCommit",
      docker: "Container",
      kubernetes: "Layers",
      terraform: "Construction",
      vault: "Vault",
      security: "Shield",
      monitoring: "Activity",
      health: "HeartPulse",

      // AI / ML
      ai: "Brain",
      ml: "Cpu",
      model: "FileJson",
      prompt: "Terminal",
      vector: "Maximize",
      neural: "Network",
      inference: "Play",

      // IoT / Edge
      iot: "Cpu",
      sensor: "Thermometer",
      device: "Watch",
      edge: "PcCase",

      // Communication
      pubsub: "Send",
      webhook: "Webhook",
      email: "Mail",
      sms: "Smartphone",
      notification: "Bell",
      signal: "Wifi",
      bus: "Truck",

      // Business
      payment_gateway: "CreditCard",
      crm: "Users",
      erp: "Briefcase",
      ecommerce: "ShoppingBag",
      marketplace: "Store",
      api: "Codepen"
    };

    const iconName = iconMapping[t] || (t.includes('db') ? 'Database' : t.includes('app') ? 'Smartphone' : t.includes('server') ? 'Server' : 'CircleDot');

    // Direct match search for Lucide icons as a fallback
    let LucideIcon = (Icons as any)[iconName];
    if (!LucideIcon) {
      // Try to find a direct match by formatting the type (e.g. "api_gateway" -> "Activity") 
      // or using the type itself if it's already a Lucide icon name.
      const pascalCase = t.split(/_|-|\s+/).map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('');
      LucideIcon = (Icons as any)[pascalCase] || (Icons as any)[t.charAt(0).toUpperCase() + t.slice(1)] || Icons.CircleDot;
    }

    return <LucideIcon size={24} strokeWidth={1.5} color="currentColor" />;
  };

  const handleStyle = { width: 6, height: 6, background: nodeStyle.accent, border: '2px solid var(--bg)', zIndex: 10 };

  if (nodeType === 'group') {
    return (
      <div style={{ padding: '40px', borderRadius: '8px', border: `2px dashed ${nodeStyle.border}`, width: '100%', height: '100%', position: 'relative' }}>
        <div style={{ position: 'absolute', top: '-12px', left: '12px', background: 'var(--bg)', padding: '0 8px', fontSize: '11px', fontWeight: '900', textTransform: 'uppercase', color: nodeStyle.color }}>{data.label}</div>
      </div>
    );
  }

  return (
    <div style={{ minWidth: '180px', background: nodeStyle.background, border: `2px solid ${nodeStyle.border}`, borderRadius: '4px', boxShadow: selected ? 'var(--node-shadow)' : 'none', transition: 'all 0.1s ease', position: 'relative', overflow: 'hidden' }}>
      <div style={{ display: 'flex', alignItems: 'center', padding: '12px 16px', gap: '12px' }}>
        <div style={{ color: nodeStyle.color, flexShrink: 0 }}>{getSVGIcon(nodeType)}</div>
        <div style={{ display: 'flex', flexDirection: 'column', borderLeft: `1px solid ${nodeStyle.border}`, paddingLeft: '12px', minHeight: '32px' }}>
          <div style={{ fontSize: '14px', fontWeight: '700', color: nodeStyle.color, lineHeight: '1.2' }}>{data.label}</div>
          <div style={{ fontSize: '9px', textTransform: 'uppercase', color: 'var(--secondary-text)', marginTop: '2px', fontWeight: 'bold' }}>{nodeType}</div>
        </div>
      </div>
      {['l', 'r', 't', 'b'].flatMap(p => ['s', 't'].map(s => {
        const handleContainerStyle = {
          width: 24,
          height: 24,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          background: 'transparent',
          borderRadius: '50%',
          cursor: 'crosshair',
          pointerEvents: 'all' as const,
          border: 'none',
          minWidth: 0,
          minHeight: 0,
        };
        const handleInnerStyle = {
          width: 8,
          height: 8,
          background: nodeStyle.accent,
          border: '2.5px solid var(--bg)',
          borderRadius: '50%',
          pointerEvents: 'none' as const,
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
        };

        return (
          <Handle
            key={p + s}
            type={s === 's' ? 'source' : 'target'}
            position={p === 'l' ? Position.Left : p === 'r' ? Position.Right : p === 't' ? Position.Top : Position.Bottom}
            id={`${p}-${s}`}
            style={{
              ...handleContainerStyle,
              ...(p === 'l' ? { left: -12 } : {}),
              ...(p === 'r' ? { right: -12 } : {}),
              ...(p === 't' ? { top: -12 } : {}),
              ...(p === 'b' ? { bottom: -12 } : {}),
            }}
          >
            <div className="handle-inner-dot" style={handleInnerStyle} />
          </Handle>
        );
      }))}
    </div>
  );
}

const nodeTypes = { default: CustomNode };

function DiagramCanvasInner() {
  const nodes = useAppStore(s => s.rfNodes);
  const edges = useAppStore(s => s.rfEdges);
  const onNodesChange = useAppStore(s => s.onNodesChange);
  const onEdgesChange = useAppStore(s => s.onEdgesChange);
  const onConnect = useAppStore(s => s.onConnect);
  const fromReactFlow = useAppStore(s => s.fromReactFlow);
  const layoutTrigger = useAppStore(s => s.layoutTrigger);
  const addNodeStore = useAppStore(s => s.addNode);

  const reactFlow = useReactFlow();
  const wrapperRef = useRef<HTMLDivElement>(null);
  const [toolsOpen, setToolsOpen] = React.useState(false);
  const [searchTerm, setSearchTerm] = React.useState("");

  const lastProcessedVersion = useRef("");
  const graphVersion = useAppStore(s => s.graph.version);

  const runLayout = useCallback(() => {
    const { rfNodes, rfEdges, layoutDirection, layoutRanker } = useAppStore.getState();
    if (rfNodes.length === 0) return;

    console.log(`ðŸš€ Layout: ${layoutDirection} using ${layoutRanker}`);
    const { density, ranker, direction } = resolveLayoutOptions(rfNodes, rfEdges, layoutDirection, layoutRanker);
    const { nodes: ln, edges: le } = getLayoutedElements(rfNodes, rfEdges, direction, density, ranker);

    fromReactFlow(ln, calculateEdgeHandles(ln, le));

    setTimeout(() => {
      reactFlow.fitView({ padding: 0.3, duration: 400 });
    }, 100);
  }, [fromReactFlow, reactFlow]);

  useEffect(() => {
    if (layoutTrigger > 0) runLayout();
  }, [layoutTrigger, runLayout]);

  // Initial layout and generation detection
  useEffect(() => {
    if (graphVersion !== lastProcessedVersion.current) {
      const currentVersion = graphVersion;
      lastProcessedVersion.current = currentVersion;

      const isExternal = !currentVersion.startsWith("local_");

      const isStacked = nodes.length > 0 && nodes.length < 50 && nodes.every(n => n.position.x === 100 && n.position.y === 100);

      if ((isExternal || isStacked) && nodes.length > 0) {
        console.log("âœ¨ Layout trigger (external or stacked), auto-positioning...");
        runLayout();
      }
    }
  }, [graphVersion, runLayout]);

  const addNode = (type: string, label: string) => {
    const b = wrapperRef.current?.getBoundingClientRect();
    const pos = reactFlow.screenToFlowPosition({ x: (b?.left || 0) + (b?.width || 0) / 2, y: (b?.top || 0) + (b?.height || 0) / 2 });
    addNodeStore(type, label, pos);
  };

  const onDownload = useCallback(() => {
    const b = getNodesBounds(nodes);
    const p = 50;
    const ve = document.querySelector(".react-flow__viewport") as HTMLElement;
    if (!ve) return;
    toPng(ve, {
      backgroundColor: "#0a0a0a",
      width: b.width + p * 2,
      height: b.height + p * 2,
      pixelRatio: 2,
      style: {
        width: (b.width + p * 2).toString(),
        height: (b.height + p * 2).toString(),
        transform: `translate(${-b.x + p}px, ${-b.y + p}px)`
      }
    }).then(dataUrl => {
      const link = document.createElement("a");
      link.href = dataUrl;
      link.download = "diagram.png";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  }, [nodes]);

  const onDragStart = (event: React.DragEvent, nodeType: string) => {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const type = event.dataTransfer.getData('application/reactflow');
      if (typeof type === 'undefined' || !type) return;

      const position = reactFlow.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });

      addNodeStore(type, type.charAt(0).toUpperCase() + type.slice(1).replace('_', ' '), position);
    },
    [reactFlow, addNodeStore]
  );

  const categories = [
    { title: "Temel BileÅŸenler", items: ["process", "decision", "actor", "group", "note", "logic", "rule_engine", "workflow"] },
    { title: "Frontend / UX", items: ["web_client", "mobile_app", "user", "tablet", "desktop", "dashboard", "form", "ui_kit", "search_bar"] },
    { title: "Backend / Logic", items: ["api_gateway", "load_balancer", "microservice", "server", "lambda", "cloud_service", "auth_service", "worker", "cron", "queue_worker", "graphql_api", "rest_api", "grpc_service"] },
    { title: "Veri / Depolama", items: ["sql_database", "nosql", "cache", "message_broker", "object_storage", "queue", "storage", "search", "logging", "analytics", "big_data", "data_warehouse", "vector_db", "redis_cache", "elasticsearch", "mongodb", "postgres"] },
    { title: "AltyapÄ± / Cloud", items: ["cloud", "vpc", "subnet", "firewall", "cdn", "dns", "vpn", "region", "zone", "load_balancer_l4", "load_balancer_l7", "global_accelerator", "nat_gateway", "internet_gateway", "peering"] },
    { title: "DevSecOps", items: ["jenkins", "git", "docker", "kubernetes", "terraform", "vault", "security", "monitoring", "health", "github_actions", "gitlab_ci", "ansible", "prometheus", "grafana", "sonarqube", "snyk"] },
    { title: "AI / ML", items: ["ai", "ml", "model", "prompt", "vector", "neural", "inference", "training", "llm_agent", "nlp_processor", "vision_service", "gpu_instance"] },
    { title: "IoT / Edge", items: ["iot", "sensor", "device", "edge", "gateway", "smart_camera", "embedded_system", "beacon", "rfid_reader"] },
    { title: "Ä°letiÅŸim", items: ["pubsub", "webhook", "email", "sms", "notification", "signal", "bus", "mqtt_broker", "socket_io", "kafka_stream", "rabbitmq"] },
    { title: "Ä°ÅŸ / Harici", items: ["payment_gateway", "crm", "erp", "ecommerce", "marketplace", "api", "stripe", "paypal", "slack_integration", "jira_sync", "salesforce"] },
    { title: "GÃ¼venlik", items: ["shield", "lock", "key", "vpn", "firewall", "iam", "active_directory", "okta", "single_sign_on", "mfa", "encryption", "audit_log"] },
    { title: "Medya / Ä°Ã§erik", items: ["image", "video", "audio", "file", "pdf", "cms", "media_convert", "streaming_server", "bucket_s3"] },
    { title: "Daha Fazla...", items: ["terminal", "test", "bug", "coffee", "heart", "star", "wrench", "hammer", "tool", "map", "compass", "anchor", "briefcase", "building", "graduation-cap", "landmark", "library", "school"] }
  ];

  return (
    <div ref={wrapperRef} style={{ width: "100%", height: "100vh", position: "relative", display: "flex", overflow: "hidden" }}>
      <div style={{ position: "absolute", top: 16, left: 16, zIndex: 10, display: "flex", gap: 8, padding: "8px 10px", borderRadius: 12, background: "var(--card-bg)", border: "1px solid var(--border)", boxShadow: "0 6px 18px rgba(0,0,0,0.08)" }}>
        <button type="button" onClick={onDownload}>PNG</button>
        <button type="button" onClick={() => setToolsOpen(!toolsOpen)} style={{ background: toolsOpen ? 'var(--accent)' : 'transparent', color: toolsOpen ? 'white' : 'var(--text)' }}>
          {toolsOpen ? "Kapat" : "BileÅŸenler"}
        </button>
        <button type="button" onClick={() => useAppStore.getState().triggerLayout()} style={{ background: 'var(--accent)', color: 'white' }}>Oto YerleÅŸtir</button>
      </div>

      <div style={{ flex: 1, position: "relative" }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          connectionMode={ConnectionMode.Loose}
          onDragOver={onDragOver}
          onDrop={onDrop}
          fitView
          panOnDrag={true}
          panOnScroll={true}
          zoomOnPinch={true}
          zoomOnScroll={true}
          zoomOnDoubleClick={true}
          selectNodesOnDrag={true}
          nodesDraggable={true}
          nodesConnectable={true}
        >
          <Background />
          <Controls />
          <MiniMap style={{ bottom: 20, right: toolsOpen ? 20 : 20, border: '1px solid var(--border)', background: 'var(--card-bg)', borderRadius: 12, overflow: 'hidden', boxShadow: '0 4px 12px rgba(0,0,0,0.1)' }} />
        </ReactFlow>
      </div>

      <div style={{
        width: toolsOpen ? 280 : 0,
        height: '100%',
        maxHeight: '100vh',
        background: 'var(--card-bg)',
        borderLeft: toolsOpen ? '1px solid var(--border)' : 'none',
        transition: 'width 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        overflow: 'hidden',
        display: 'flex',
        flexDirection: 'column',
        zIndex: 100,
        flexShrink: 0
      }}>
        <div style={{ padding: '20px 20px 10px 20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: 'var(--card-bg)', flexShrink: 0 }}>
          <h3 style={{ margin: 0, fontSize: '15px', fontWeight: '800', textTransform: 'uppercase', letterSpacing: '1px' }}>KÃ¼tÃ¼phane</h3>
          <button onClick={() => setToolsOpen(false)} style={{ background: 'transparent', border: 'none', color: 'var(--text)', cursor: 'pointer', fontSize: '24px', lineHeight: '1' }}>&times;</button>
        </div>

        <div style={{ padding: '0 20px 15px 20px', borderBottom: '1px solid var(--border)', flexShrink: 0 }}>
          <input
            type="text"
            placeholder="BileÅŸen ara..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            style={{
              width: '100%',
              padding: '8px 12px',
              fontSize: '12px',
              borderRadius: '6px',
              background: 'var(--bg)',
              border: '1px solid var(--border)',
              color: 'var(--text)',
              outline: 'none'
            }}
          />
        </div>

        <div style={{ flex: 1, overflowY: 'auto', padding: '12px', background: 'var(--card-bg)' }} className="sidebar-scrollable">
          <style>{`
            .sidebar-scrollable::-webkit-scrollbar { width: 4px; }
            .sidebar-scrollable::-webkit-scrollbar-track { background: transparent; }
            .sidebar-scrollable::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }
            .sidebar-btn { text-align: left; font-size: 11px; padding: 10px 12px; border-radius: 8px; background: transparent; border: 1px solid transparent; color: var(--text); cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 10px; width: 100%; margin-bottom: 4px; }
            .sidebar-btn:hover { background: var(--border); transform: translateX(4px); }
            .sidebar-cat-title { font-size: 10px; text-transform: uppercase; letter-spacing: 0.12em; opacity: 0.5; padding: 16px 12px 8px 12px; font-weight: 800; color: var(--text); }
          `}</style>

          {categories.map(cat => {
            const filteredItems = cat.items.filter(item =>
              item.toLowerCase().includes(searchTerm.toLowerCase()) ||
              cat.title.toLowerCase().includes(searchTerm.toLowerCase())
            );

            if (filteredItems.length === 0) return null;

            return (
              <React.Fragment key={cat.title}>
                <div className="sidebar-cat-title">{cat.title}</div>
                {filteredItems.map(t => (
                  <button
                    key={t}
                    className="sidebar-btn"
                    onClick={() => addNode(t, t.charAt(0).toUpperCase() + t.slice(1).replace('_', ' '))}
                    draggable
                    onDragStart={(e) => onDragStart(e, t)}
                    title="SÃ¼rÃ¼kleyip bÄ±rakabilirsin"
                  >
                    + {t.replace('_', ' ').toUpperCase()}
                  </button>
                ))}
              </React.Fragment>
            );
          })}

          {searchTerm && searchTerm.length >= 2 && (
            <>
              <div className="sidebar-cat-title">TÃ¼m KÃ¼tÃ¼phane SonuÃ§larÄ±</div>
              {Object.keys(Icons)
                .filter(iconName =>
                  iconName.toLowerCase().includes(searchTerm.toLowerCase()) &&
                  !categories.some(c => c.items.includes(iconName.toLowerCase()))
                )
                .slice(0, 50)
                .map(iconName => (
                  <button
                    key={iconName}
                    className="sidebar-btn"
                    onClick={() => addNode(iconName, iconName.replace(/([A-Z])/g, ' $1').trim())}
                    draggable
                    onDragStart={(e) => onDragStart(e, iconName)}
                    title={`${iconName} ikonunu ekle`}
                  >
                    + {iconName.replace(/([A-Z])/g, ' $1').trim().toUpperCase()}
                  </button>
                ))
              }
            </>
          )}

          <div style={{ borderTop: '1px solid var(--border)', marginTop: 20, paddingTop: 12 }}>
            <button className="sidebar-btn" style={{ color: '#ff4444' }} onClick={() => useAppStore.getState().deleteSelection()}>SeÃ§ilenleri Sil</button>
            <button className="sidebar-btn" style={{ color: '#ff4444' }} onClick={() => useAppStore.getState().setGraph({ version: 'v_clear', nodes: [], edges: [] })}>Hepsini Temizle</button>
          </div>
        </div>
      </div>
    </div>
  );
}

export default function DiagramCanvas() {
  return (
    <ReactFlowProvider>
      <DiagramCanvasInner />
    </ReactFlowProvider>
  );
}
